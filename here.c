// This file was automatically generated by odin.
// Do not edit by hand as changes will be lost.

// versions:
// hash: 7246dfe937fd06e856564588b39b1c98
// odin: 0.0.3
// cinterpolate: 0.0.1
// r: 3.4.4
// platform: x86_64-w64-mingw32

#include <R.h>
#include <Rmath.h>
#include <Rinternals.h>
#include <R_ext/Rdynload.h>
#include <stdbool.h>

// Collect together all the parameters and transient memory
// required to run the model in a struct.
typedef struct sir_mult_pars {
  int odin_use_dde;
  int np;
  int dim_S;
  double *initial_S;
  int offset_S;
  int dim_I;
  double *initial_I;
  int offset_I;
  int dim_R;
  double *initial_R;
  int offset_R;
  int dim_beta;
  double *beta;
  int dim_put;
  int dim_put_1;
  int dim_put_2;
  double *put;
  int dim_N;
  double *N;
  int dim_delta;
  double *delta;
  int dim_alpha;
  int dim_alpha_1;
  int dim_alpha_2;
  double *alpha;
  int dim_ro;
  double *ro;
  int dim_lambda;
  double *lambda;
  int dim_I0;
  double *I0;
  int dim;
} sir_mult_pars;
sir_mult_pars* sir_mult_get_pointer(SEXP sir_mult_ptr, int closed_error);
SEXP sir_mult_set_user(sir_mult_pars *sir_mult_p, SEXP user);

SEXP get_ds_pars();
int get_user_int(SEXP user, const char *name, int default_value);
void odin_set_dim(SEXP target, int nd, ...);
void get_user_array(SEXP user, const char *name, bool is_real, void *dest, int nd, ...);
SEXP get_user_array_check_rank(SEXP user, const char *name, int nd);
void get_user_array_copy(SEXP el, const char *name, bool is_real, void *dest);
SEXP get_list_element(SEXP list, const char *name);
double odin_sum2(double *x, int from_i, int to_i, int from_j, int to_j, int dim_x_1);

// Create the pointer; this will establish the struct, allocate
// memory for things that are constant size, and initialize
// constant variables
static void sir_mult_finalize(SEXP sir_mult_ptr);
SEXP sir_mult_create(SEXP user, SEXP odin_use_dde) {
  sir_mult_pars *sir_mult_p = (sir_mult_pars*) Calloc(1, sir_mult_pars);
  sir_mult_p->np = 3;
  sir_mult_p->initial_S = NULL;
  sir_mult_p->initial_I = NULL;
  sir_mult_p->initial_R = NULL;
  sir_mult_p->beta = NULL;
  sir_mult_p->put = NULL;
  sir_mult_p->N = NULL;
  sir_mult_p->delta = NULL;
  sir_mult_p->alpha = NULL;
  sir_mult_p->ro = NULL;
  sir_mult_p->lambda = NULL;
  sir_mult_p->I0 = NULL;
  SEXP sir_mult_ptr = PROTECT(R_MakeExternalPtr(sir_mult_p, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(sir_mult_ptr, sir_mult_finalize);
  sir_mult_set_user(sir_mult_p, user);
  sir_mult_p->odin_use_dde = INTEGER(odin_use_dde)[0];
  UNPROTECT(1);
  return sir_mult_ptr;
}

// Set user-supplied parameter values.
SEXP sir_mult_set_user(sir_mult_pars *sir_mult_p, SEXP user) {
  sir_mult_p->np = get_user_int(user, "np", sir_mult_p->np);
  Free(sir_mult_p->initial_S);
  sir_mult_p->dim_S = sir_mult_p->np;
  sir_mult_p->initial_S = (double*) Calloc(sir_mult_p->dim_S, double);
  sir_mult_p->offset_S = 0;
  Free(sir_mult_p->initial_I);
  sir_mult_p->dim_I = sir_mult_p->np;
  sir_mult_p->initial_I = (double*) Calloc(sir_mult_p->dim_I, double);
  sir_mult_p->offset_I = sir_mult_p->dim_S;
  Free(sir_mult_p->initial_R);
  sir_mult_p->dim_R = sir_mult_p->np;
  sir_mult_p->initial_R = (double*) Calloc(sir_mult_p->dim_R, double);
  sir_mult_p->offset_R = sir_mult_p->offset_I + sir_mult_p->dim_I;
  Free(sir_mult_p->beta);
  sir_mult_p->dim_beta = sir_mult_p->np;
  sir_mult_p->beta = (double*) Calloc(sir_mult_p->dim_beta, double);
  for (int i = 0; i < sir_mult_p->np; ++i) {
    sir_mult_p->initial_R[i] = 0;
  }
  Free(sir_mult_p->put);
  sir_mult_p->dim_put_1 = sir_mult_p->np;
  sir_mult_p->dim_put_2 = sir_mult_p->np;
  sir_mult_p->dim_put = sir_mult_p->dim_put_1 * sir_mult_p->dim_put_2;
  sir_mult_p->put = (double*) Calloc(sir_mult_p->dim_put, double);
  Free(sir_mult_p->N);
  sir_mult_p->dim_N = sir_mult_p->np;
  sir_mult_p->N = (double*) Calloc(sir_mult_p->dim_N, double);
  get_user_array(user, "N", true, sir_mult_p->N, 1, sir_mult_p->dim_N);
  Free(sir_mult_p->delta);
  sir_mult_p->dim_delta = sir_mult_p->np;
  sir_mult_p->delta = (double*) Calloc(sir_mult_p->dim_delta, double);
  get_user_array(user, "delta", true, sir_mult_p->delta, 1, sir_mult_p->dim_delta);
  Free(sir_mult_p->alpha);
  sir_mult_p->dim_alpha_1 = sir_mult_p->np;
  sir_mult_p->dim_alpha_2 = sir_mult_p->np;
  sir_mult_p->dim_alpha = sir_mult_p->dim_alpha_1 * sir_mult_p->dim_alpha_2;
  sir_mult_p->alpha = (double*) Calloc(sir_mult_p->dim_alpha, double);
  get_user_array(user, "alpha", true, sir_mult_p->alpha, 2, sir_mult_p->dim_alpha_1, sir_mult_p->dim_alpha_2);
  Free(sir_mult_p->ro);
  sir_mult_p->dim_ro = sir_mult_p->np;
  sir_mult_p->ro = (double*) Calloc(sir_mult_p->dim_ro, double);
  get_user_array(user, "ro", true, sir_mult_p->ro, 1, sir_mult_p->dim_ro);
  for (int i = 0; i < sir_mult_p->dim_beta; ++i) {
    sir_mult_p->beta[i] = sir_mult_p->ro[i] * sir_mult_p->delta[i];
  }
  Free(sir_mult_p->lambda);
  sir_mult_p->dim_lambda = sir_mult_p->np;
  sir_mult_p->lambda = (double*) Calloc(sir_mult_p->dim_lambda, double);
  for (int i = 0; i < sir_mult_p->np; ++i) {
    sir_mult_p->lambda[i] = 1;
  }
  Free(sir_mult_p->I0);
  sir_mult_p->dim_I0 = sir_mult_p->np;
  sir_mult_p->I0 = (double*) Calloc(sir_mult_p->dim_I0, double);
  get_user_array(user, "I0", true, sir_mult_p->I0, 1, sir_mult_p->dim_I0);
  for (int i = 0; i < sir_mult_p->np; ++i) {
    sir_mult_p->initial_S[i] = sir_mult_p->N[i] - sir_mult_p->I0[i];
  }
  for (int i = 0; i < sir_mult_p->np; ++i) {
    sir_mult_p->initial_I[i] = sir_mult_p->I0[i];
  }
  sir_mult_p->dim = sir_mult_p->offset_R + sir_mult_p->dim_R;
  return R_NilValue;
}
// Wrapper around this for use from R.
SEXP r_sir_mult_set_user(SEXP sir_mult_ptr, SEXP user) {
  sir_mult_pars *sir_mult_p = sir_mult_get_pointer(sir_mult_ptr, 1);
  sir_mult_set_user(sir_mult_p, user);
  return R_NilValue;
}

// Arrange to free all memory we have allocated
// This is called by R automatically when the pointer is
// garbage collected (i.e., when all objects holding the pointer
// go out of scope
void sir_mult_finalize(SEXP sir_mult_ptr) {
  sir_mult_pars *sir_mult_p = sir_mult_get_pointer(sir_mult_ptr, 0);
  if (sir_mult_ptr) {
    Free(sir_mult_p->initial_S);
    Free(sir_mult_p->initial_I);
    Free(sir_mult_p->initial_R);
    Free(sir_mult_p->beta);
    Free(sir_mult_p->put);
    Free(sir_mult_p->N);
    Free(sir_mult_p->delta);
    Free(sir_mult_p->alpha);
    Free(sir_mult_p->ro);
    Free(sir_mult_p->lambda);
    Free(sir_mult_p->I0);
    Free(sir_mult_p);
    R_ClearExternalPtr(sir_mult_ptr);
  }
}

SEXP sir_mult_initialise(SEXP sir_mult_ptr, SEXP t_ptr) {
  sir_mult_pars *sir_mult_p = sir_mult_get_pointer(sir_mult_ptr, 1);
  SEXP state = PROTECT(allocVector(REALSXP, sir_mult_p->dim));
  memcpy(REAL(state) + 0, sir_mult_p->initial_S, sir_mult_p->dim_S * sizeof(double));
  memcpy(REAL(state) + sir_mult_p->offset_I, sir_mult_p->initial_I, sir_mult_p->dim_I * sizeof(double));
  memcpy(REAL(state) + sir_mult_p->offset_R, sir_mult_p->initial_R, sir_mult_p->dim_R * sizeof(double));
  UNPROTECT(1);
  return state;
}

SEXP sir_mult_set_initial(SEXP sir_mult_ptr, SEXP t_ptr, SEXP state_ptr) {
  return R_NilValue;
}

void sir_mult_deriv(sir_mult_pars *sir_mult_p, double t, double *state, double *dstatedt, double *output) {
  double *S = state;
  double *I = state + sir_mult_p->offset_I;
  double *deriv_S = dstatedt;
  double *deriv_I = dstatedt + sir_mult_p->offset_I;
  double *deriv_R = dstatedt + sir_mult_p->offset_R;
  for (int i = 0; i < sir_mult_p->np; ++i) {
    deriv_R[i] = sir_mult_p->delta[i] * I[i];
  }
  for (int i = 0; i < sir_mult_p->np; ++i) {
    deriv_S[i] = -sir_mult_p->lambda[i] * S[i];
  }
  for (int i = 0; i < sir_mult_p->np; ++i) {
    deriv_I[i] = sir_mult_p->lambda[i] * S[i] * sir_mult_p->delta[i] * I[i];
  }
}

// deSolve interface
// Global variable set on initmod, as per deSolve design
static sir_mult_pars *sir_mult_p;
void sir_mult_initmod_ds(void(* odeparms) (int *, double *)) {
  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  sir_mult_p = sir_mult_get_pointer(get_deSolve_gparms(), 1);
}
void sir_mult_deriv_ds(int *neq, double *t, double *state,
                       double *dstatedt, double *output, int *np) {
  sir_mult_deriv(sir_mult_p, *t, state, dstatedt, output);
}

// dde interface
void sir_mult_deriv_dde(size_t n_eq, double t, double *state,
                         double *dstatedt, void *sir_mult_p) {
  sir_mult_deriv((sir_mult_pars*)sir_mult_p, t, state, dstatedt, NULL);
}

SEXP sir_mult_deriv_r(SEXP sir_mult_ptr, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  sir_mult_pars *sir_mult_p = sir_mult_get_pointer(sir_mult_ptr, 1);
  double *output = NULL;
  sir_mult_deriv(sir_mult_p, REAL(t)[0], REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}

// Translate all elements in the struct back to R
// This will mostly be useful for debugging.
SEXP sir_mult_contents(SEXP sir_mult_ptr) {
  sir_mult_pars *sir_mult_p = sir_mult_get_pointer(sir_mult_ptr, 1);
  SEXP state = PROTECT(allocVector(VECSXP, 32));
  SET_VECTOR_ELT(state, 0, ScalarInteger(sir_mult_p->odin_use_dde));
  SET_VECTOR_ELT(state, 1, ScalarInteger(sir_mult_p->np));
  SET_VECTOR_ELT(state, 2, ScalarInteger(sir_mult_p->dim_S));
  SET_VECTOR_ELT(state, 3, allocVector(REALSXP, sir_mult_p->dim_S));
  memcpy(REAL(VECTOR_ELT(state, 3)), sir_mult_p->initial_S, sir_mult_p->dim_S * sizeof(double));
  SET_VECTOR_ELT(state, 4, ScalarInteger(sir_mult_p->offset_S));
  SET_VECTOR_ELT(state, 5, ScalarInteger(sir_mult_p->dim_I));
  SET_VECTOR_ELT(state, 6, allocVector(REALSXP, sir_mult_p->dim_I));
  memcpy(REAL(VECTOR_ELT(state, 6)), sir_mult_p->initial_I, sir_mult_p->dim_I * sizeof(double));
  SET_VECTOR_ELT(state, 7, ScalarInteger(sir_mult_p->offset_I));
  SET_VECTOR_ELT(state, 8, ScalarInteger(sir_mult_p->dim_R));
  SET_VECTOR_ELT(state, 9, allocVector(REALSXP, sir_mult_p->dim_R));
  memcpy(REAL(VECTOR_ELT(state, 9)), sir_mult_p->initial_R, sir_mult_p->dim_R * sizeof(double));
  SET_VECTOR_ELT(state, 10, ScalarInteger(sir_mult_p->offset_R));
  SET_VECTOR_ELT(state, 11, ScalarInteger(sir_mult_p->dim_beta));
  SET_VECTOR_ELT(state, 12, allocVector(REALSXP, sir_mult_p->dim_beta));
  memcpy(REAL(VECTOR_ELT(state, 12)), sir_mult_p->beta, sir_mult_p->dim_beta * sizeof(double));
  SET_VECTOR_ELT(state, 13, ScalarInteger(sir_mult_p->dim_put));
  SET_VECTOR_ELT(state, 14, ScalarInteger(sir_mult_p->dim_put_1));
  SET_VECTOR_ELT(state, 15, ScalarInteger(sir_mult_p->dim_put_2));
  SET_VECTOR_ELT(state, 16, allocVector(REALSXP, sir_mult_p->dim_put));
  memcpy(REAL(VECTOR_ELT(state, 16)), sir_mult_p->put, sir_mult_p->dim_put * sizeof(double));
  odin_set_dim(VECTOR_ELT(state, 16), 2, sir_mult_p->dim_put_1, sir_mult_p->dim_put_2);
  SET_VECTOR_ELT(state, 17, ScalarInteger(sir_mult_p->dim_N));
  SET_VECTOR_ELT(state, 18, allocVector(REALSXP, sir_mult_p->dim_N));
  memcpy(REAL(VECTOR_ELT(state, 18)), sir_mult_p->N, sir_mult_p->dim_N * sizeof(double));
  SET_VECTOR_ELT(state, 19, ScalarInteger(sir_mult_p->dim_delta));
  SET_VECTOR_ELT(state, 20, allocVector(REALSXP, sir_mult_p->dim_delta));
  memcpy(REAL(VECTOR_ELT(state, 20)), sir_mult_p->delta, sir_mult_p->dim_delta * sizeof(double));
  SET_VECTOR_ELT(state, 21, ScalarInteger(sir_mult_p->dim_alpha));
  SET_VECTOR_ELT(state, 22, ScalarInteger(sir_mult_p->dim_alpha_1));
  SET_VECTOR_ELT(state, 23, ScalarInteger(sir_mult_p->dim_alpha_2));
  SET_VECTOR_ELT(state, 24, allocVector(REALSXP, sir_mult_p->dim_alpha));
  memcpy(REAL(VECTOR_ELT(state, 24)), sir_mult_p->alpha, sir_mult_p->dim_alpha * sizeof(double));
  odin_set_dim(VECTOR_ELT(state, 24), 2, sir_mult_p->dim_alpha_1, sir_mult_p->dim_alpha_2);
  SET_VECTOR_ELT(state, 25, ScalarInteger(sir_mult_p->dim_ro));
  SET_VECTOR_ELT(state, 26, allocVector(REALSXP, sir_mult_p->dim_ro));
  memcpy(REAL(VECTOR_ELT(state, 26)), sir_mult_p->ro, sir_mult_p->dim_ro * sizeof(double));
  SET_VECTOR_ELT(state, 27, ScalarInteger(sir_mult_p->dim_lambda));
  SET_VECTOR_ELT(state, 28, allocVector(REALSXP, sir_mult_p->dim_lambda));
  memcpy(REAL(VECTOR_ELT(state, 28)), sir_mult_p->lambda, sir_mult_p->dim_lambda * sizeof(double));
  SET_VECTOR_ELT(state, 29, ScalarInteger(sir_mult_p->dim_I0));
  SET_VECTOR_ELT(state, 30, allocVector(REALSXP, sir_mult_p->dim_I0));
  memcpy(REAL(VECTOR_ELT(state, 30)), sir_mult_p->I0, sir_mult_p->dim_I0 * sizeof(double));
  SET_VECTOR_ELT(state, 31, ScalarInteger(sir_mult_p->dim));
  SEXP state_names = PROTECT(allocVector(STRSXP, 32));
  SET_STRING_ELT(state_names, 0, mkChar("odin_use_dde"));
  SET_STRING_ELT(state_names, 1, mkChar("np"));
  SET_STRING_ELT(state_names, 2, mkChar("dim_S"));
  SET_STRING_ELT(state_names, 3, mkChar("initial_S"));
  SET_STRING_ELT(state_names, 4, mkChar("offset_S"));
  SET_STRING_ELT(state_names, 5, mkChar("dim_I"));
  SET_STRING_ELT(state_names, 6, mkChar("initial_I"));
  SET_STRING_ELT(state_names, 7, mkChar("offset_I"));
  SET_STRING_ELT(state_names, 8, mkChar("dim_R"));
  SET_STRING_ELT(state_names, 9, mkChar("initial_R"));
  SET_STRING_ELT(state_names, 10, mkChar("offset_R"));
  SET_STRING_ELT(state_names, 11, mkChar("dim_beta"));
  SET_STRING_ELT(state_names, 12, mkChar("beta"));
  SET_STRING_ELT(state_names, 13, mkChar("dim_put"));
  SET_STRING_ELT(state_names, 14, mkChar("dim_put_1"));
  SET_STRING_ELT(state_names, 15, mkChar("dim_put_2"));
  SET_STRING_ELT(state_names, 16, mkChar("put"));
  SET_STRING_ELT(state_names, 17, mkChar("dim_N"));
  SET_STRING_ELT(state_names, 18, mkChar("N"));
  SET_STRING_ELT(state_names, 19, mkChar("dim_delta"));
  SET_STRING_ELT(state_names, 20, mkChar("delta"));
  SET_STRING_ELT(state_names, 21, mkChar("dim_alpha"));
  SET_STRING_ELT(state_names, 22, mkChar("dim_alpha_1"));
  SET_STRING_ELT(state_names, 23, mkChar("dim_alpha_2"));
  SET_STRING_ELT(state_names, 24, mkChar("alpha"));
  SET_STRING_ELT(state_names, 25, mkChar("dim_ro"));
  SET_STRING_ELT(state_names, 26, mkChar("ro"));
  SET_STRING_ELT(state_names, 27, mkChar("dim_lambda"));
  SET_STRING_ELT(state_names, 28, mkChar("lambda"));
  SET_STRING_ELT(state_names, 29, mkChar("dim_I0"));
  SET_STRING_ELT(state_names, 30, mkChar("I0"));
  SET_STRING_ELT(state_names, 31, mkChar("dim"));
  setAttrib(state, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state;
}

// Report back to R information on variable ordering
// The reported information includes position and length of each
// variable, from which offset, etc, can be worked out.
SEXP sir_mult_variable_order(SEXP sir_mult_ptr) {
  sir_mult_pars *sir_mult_p = sir_mult_get_pointer(sir_mult_ptr, 1);
  SEXP state_len = PROTECT(allocVector(VECSXP, 3));
  SEXP state_names = PROTECT(allocVector(STRSXP, 3));
  SET_VECTOR_ELT(state_len, 0, ScalarInteger(sir_mult_p->dim_S));
  SET_STRING_ELT(state_names, 0, mkChar("S"));
  SET_VECTOR_ELT(state_len, 1, ScalarInteger(sir_mult_p->dim_I));
  SET_STRING_ELT(state_names, 1, mkChar("I"));
  SET_VECTOR_ELT(state_len, 2, ScalarInteger(sir_mult_p->dim_R));
  SET_STRING_ELT(state_names, 2, mkChar("R"));
  setAttrib(state_len, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state_len;
}

sir_mult_pars* sir_mult_get_pointer(SEXP sir_mult_ptr, int closed_error) {
  sir_mult_pars *sir_mult_p = NULL;
  if (TYPEOF(sir_mult_ptr) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  sir_mult_p = (sir_mult_pars*) R_ExternalPtrAddr(sir_mult_ptr);
  if (!sir_mult_p && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return sir_mult_p;
}

SEXP get_ds_pars() {
  static DL_FUNC get_deSolve_gparms = NULL;
  if (get_deSolve_gparms == NULL) {
    get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  return get_deSolve_gparms();
}
int get_user_int(SEXP user, const char *name, int default_value) {
  int ret = default_value;
  SEXP el = get_list_element(user, name);
  if (el != R_NilValue) {
    if (length(el) != 1) {
      Rf_error("Expected scalar integer for %d", name);
    }
    ret = INTEGER(coerceVector(el, INTSXP))[0];
  }
  if (ret == NA_INTEGER) {
    Rf_error("Expected value for %s", name);
  }
  return ret;
}
void odin_set_dim(SEXP target, int nd, ...) {
  SEXP r_dim = PROTECT(allocVector(INTSXP, nd));
  int *dim = INTEGER(r_dim);

  va_list ap;
  va_start(ap, nd);
  for (size_t i = 0; i < (size_t)nd; ++i) {
    dim[i] = va_arg(ap, int);
  }
  va_end(ap);

  setAttrib(target, R_DimSymbol, r_dim);
  UNPROTECT(1);
}
void get_user_array(SEXP user, const char *name, bool is_real, void *dest, int nd, ...) {
  SEXP el = get_user_array_check_rank(user, name, nd);
  SEXP r_dim;
  int *dim;

  if (nd == 1) {
    r_dim = PROTECT(ScalarInteger(LENGTH(el)));
  } else {
    r_dim = PROTECT(coerceVector(getAttrib(el, R_DimSymbol), INTSXP));
  }
  dim = INTEGER(r_dim);

  va_list ap;
  va_start(ap, nd);
  for (size_t i = 0; i < (size_t) nd; ++i) {
    int dim_expected = va_arg(ap, int);
    if (dim[i] != dim_expected) {
      va_end(ap); // avoid a leak
      if (nd == 1) {
        Rf_error("Expected length %d value for %s", dim_expected, name);
      } else {
        Rf_error("Incorrect size of dimension %d of %s (expected %d)",
                 i + 1, name, dim_expected);
      }
    }
  }
  va_end(ap);
  UNPROTECT(1);

  get_user_array_copy(el, name, is_real, dest);
}
SEXP get_user_array_check_rank(SEXP user, const char *name, int nd) {
  SEXP el = get_list_element(user, name);
  if (el == R_NilValue) {
    Rf_error("Expected value for %s", name);
  } else {
    if (nd == 1) {
      if (isArray(el)) {
        // this may be too strict as a length-1 dim here will fail
        Rf_error("Expected a vector for %s", name);
      }
    } else {
      SEXP r_dim = getAttrib(el, R_DimSymbol);
      if (r_dim == R_NilValue || LENGTH(r_dim) != nd) {
        if (nd == 2) {
          Rf_error("Expected a matrix for %s", name);
        } else {
          Rf_error("Expected a %dd array for %s", nd, name);
        }
      }
    }
  }
  return el;
}
void get_user_array_copy(SEXP el, const char *name, bool is_real, void *dest) {
  int given_int = TYPEOF(el) == INTSXP;
  size_t n = (size_t) length(el);
  if (is_real) {
    if (given_int) {
      el = PROTECT(coerceVector(el, REALSXP));
    } else if (TYPEOF(el) != REALSXP) {
      Rf_error("Expected a numeric value for %s", name);
    }
    memcpy(dest, REAL(el), n * sizeof(double));
  } else {
    if (TYPEOF(el) == REALSXP) {
      el = PROTECT(coerceVector(el, INTSXP));
    } else if (TYPEOF(el) != INTSXP) {
      Rf_error("Expected a numeric value for %s", name);
    }
    memcpy(dest, INTEGER(el), n * sizeof(int));
  }
  if (given_int == is_real) {
    UNPROTECT(1);
  }
}
SEXP get_list_element(SEXP list, const char *name) {
  SEXP ret = R_NilValue, names = getAttrib(list, R_NamesSymbol);
  for (int i = 0; i < length(list); ++i) {
    if(strcmp(CHAR(STRING_ELT(names, i)), name) == 0) {
      ret = VECTOR_ELT(list, i);
      break;
    }
  }
  return ret;
}
double odin_sum2(double *x, int from_i, int to_i, int from_j, int to_j, int dim_x_1) {
  double tot = 0.0;
  for (int j = from_j; j <= to_j; ++j) {
    int jj = j * dim_x_1;
    for (int i = from_i; i <= to_i; ++i) {
      tot += x[i + jj];
    }
  }
  return tot;
}
